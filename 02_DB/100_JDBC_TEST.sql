-- JDBC

--부서명을 입력 받아
--해당 부서에 존재하는 사원의
--사번, 이름, 급여, 부서명을 
--사번 오름차순으로 조회 

SELECT EMP_ID, EMP_NAME, SALARY, DEPT_TITLE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
WHERE DEPT_TITLE = '총무부'
ORDER BY EMP_ID;

-- null 입력 시 
-- 해결 방법1: 상황에 따른 SQL 구문 조립 -> 이클립스 jdbc1 - edu.kh.jdbc.dao - SelectDepartmentTitleDAO
-- 해결 방법2: SQL을 바꾸는 방법
SELECT * FROM (
   SELECT EMP_ID, EMP_NAME, SALARY, NVL(DEPT_TITLE, 'null') DEPT_TITLE
   FROM EMPLOYEE 
   LEFT JOIN DEPARTMENT ON(DEPT_CODE = DEPT_ID)
   ORDER BY EMP_ID )
WHERE DEPT_TITLE = 'null';

SELECT EMP_ID, EMP_NAME, JOB_NAME, SALARY
FROM EMPLOYEE
JOIN JOB USING (JOB_CODE)
WHERE SALARY BETWEEN '2000000' AND'4000000' 
ORDER BY SALARY DESC; 

-- 5. 사원 정보 추가
-- 사번 생성을 위한 시퀀스 (223번 시작)
CREATE SEQUENCE SEQ_EMP_ID
START WITH 223 --223번 시작
INCREMENT BY 1 --1씩 증가
NOCYCLE -- 반복 없음
NOCACHE; -- 미리 만들어 두는 번호 없음

-- SEQ_EMP)ID.NEXTVAL : 다음 번호 생성
-- SEQ_EMP_ID.CURRVAL : 현재 번호 조회

UPDATE EMPLOYEE 
SET EMAIL = ?, PHONE = ?, SALARY = ?
WHERE EMP_ID = ? ;

SELECT EMP_ID, EMP_NAME, PHONE, SALARY, EMAIL
FROM EMPLOYEE
WHERE EMP_ID = 223;

UPDATE EMPLOYEE 
SET ENT_YN = 'Y', ENT_DATE = SYSDATE
WHERE EMP_ID = ? ;

SELECT EMP_ID, EMP_NAME, ENT_YN, ENT_DATE 
FROM EMPLOYEE WHERE EMP_ID = 223;


SELECT EMP_ID, EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY, PHONE
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
WHERE ENT_YN = 'N'
ORDER BY JOB_CODE;

SELECT EMP_ID, EMP_NAME, NVL(PHONE, '없음'), EMAIL, TO_CHAR(ENT_DATE, 'YYYY"년" MM"월" DD"일"') ENT_DATE
FROM EMPLOYEE
WHERE ENT_YN = 'Y'
ORDER BY ENT_DATE ;

--*****STEP 과제 제출 확인용
SELECT EMP_NAME, TO_CHAR(HIRE_DATE, 'YY/MM/DD') 작성일
FROM EMPLOYEE;


SELECT EMP_ID, EMP_NAME , DEPT_TITLE , JOB_NAME , SALARY, PHONE, EMAIL, HIRE_DATE, DECODE(ENT_YN, 'N','재직중','Y','퇴사')
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
JOIN JOB USING (JOB_CODE)
WHERE EMP_ID = ?;

---------------------------4번 사원 정보 추가
CREATE SEQUENCE SEQ_EMP_ID2
START WITH 223 --223번 시작
INCREMENT BY 1 --1씩 증가
NOCYCLE -- 반복 없음
NOCACHE; -- 미리 만들어 두는 번호 없음

-- SEQ_EMP)ID.NEXTVAL : 다음 번호 생성
-- SEQ_EMP_ID.CURRVAL : 현재 번호 조회
--------------------------------------------
UPDATE EMPLOYEE 
SET EMAIL = ?, PHONE = ?, SALARY = ?, BONUS = ?
WHERE EMP_ID = ? ;

SELECT EMP_ID, EMP_NAME, PHONE, SALARY, EMAIL, BONUS, ENT_DATE, ENT_YN  
FROM EMPLOYEE;

DELETE FROM EMPLOYEE
WHERE EMP_ID = ?;

ROLLBACK;

-- 입력 받은 사번의 사원이 존재하지 않으면 0
-- 사원은 있는데 퇴직처리된 사원이면 1
-- 사원도 있고, 재직중인 사원이면 2 조회
SELECT DECODE(ENT_YN, 'Y','1','N','2',0) "재직 여부"
FROM EMPLOYEE;

-- 선택함수 DECODE / CASE 둘 다 가능 (길어지면 CASE가 깔끔해보임)
SELECT CASE
		--존재하지 않는 사원인가?
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300) = 0
		THEN 0
		--존재하지만 퇴직한 사원인가?
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222 AND ENT_YN = 'Y') = 1
		THEN 1
		--존재는 하지만 퇴직하지 않은 사원!
		ELSE 2
	END "CHECK"
FROM DUAL;

SELECT CASE
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 300) = 0
		THEN 0
		WHEN (SELECT COUNT(*) FROM EMPLOYEE WHERE EMP_ID = 222 AND ENT_YN = 'Y') = 1
		THEN 1
		ELSE 2
	END "CHECK"
FROM DUAL;

ROLLBACK;

SELECT EMP_ID, EMP_NAME, ENT_YN
FROM EMPLOYEE;

UPDATE EMPLOYEE
SET ENT_YN = 'Y'
WHERE EMP_ID = 207;

COMMIT;

/*8.
가장 최근(입사일이 늦은) 사원 5명의
사번, 이름, 부서명, 입사일을
입사일 내림차순으로 조회
--ROWNUM, 인라인뷰(FROM절 서브쿼리)*/

SELECT * FROM
	(SELECT EMP_ID, EMP_NAME, HIRE_DATE, NVL(DEPT_TITLE,'부서없음') DEPT_TITLE
	FROM EMPLOYEE
	LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID) --NULL값 포함하기 위해
	ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <=5;

--9.
/*각 부서별
부서명, 인원 수, 급여 평균
부서코드 오름차순 조회 */
SELECT DEPT_CODE, NVL(DEPT_TITLE, '부서없음') DEPT_TITLE, COUNT(*) 인원, FLOOR(AVG(SALARY)) 평균
FROM EMPLOYEE
LEFT JOIN DEPARTMENT ON (DEPT_CODE = DEPT_ID)
GROUP BY DEPT_CODE, DEPT_TITLE
ORDER BY DEPT_CODE;